{"version":3,"file":"errorWatch.min.js","sources":["../src/config.js","../src/utils.js","../src/computeStackTrace.js","../src/resourceError.js","../src/report.js","../src/wrap.js","../src/tryCatch.js","../src/index.js"],"sourcesContent":["//Default options:\nexport const remoteFetching = false;     // 获取远程源文件，没什么用关掉\nexport const collectWindowErrors = true; // 是否通知 window 全局错误，开启，关掉了这个脚本就没意义了\nexport const collectSourceErrors = true; // 是否在捕获阶段获取资源加载错误，默认开启\nexport const linesOfContext = 11;        // 5 lines before, the offending line, 5 lines after，没啥用\nexport const debug = false;\nexport const reportFuncName = 'ErrorWatch.report';\n","/**\n * A better form of hasOwnProperty<br/>\n * Example: `_has(MainHostObject, property) === true/false`\n *\n * @param {Object} object to check property\n * @param {string} key to check\n * @return {Boolean} true if the object has the key and it is not inherited\n */\nexport function _has(object, key) {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}\n\n/**\n * Returns true if the parameter is undefined<br/>\n * Example: `_isUndefined(val) === true/false`\n *\n * @param {*} what Value to check\n * @return {Boolean} true if undefined and false otherwise\n */\nexport function _isUndefined(what) {\n  return typeof what === 'undefined';\n}","/**\n * An object representing a single stack frame.\n * @typedef {Object} StackFrame\n * @property {string} url The JavaScript or HTML file URL.\n * @property {string} func The function name, or empty for anonymous functions (if guessing did not work).\n * @property {string[]?} args The arguments passed to the function, if known.\n * @property {number=} line The line number, if known.\n * @property {number=} column The column number, if known.\n * @property {string[]} context An array of source code lines; the middle element corresponds to the correct line#.\n * @memberof ErrorWatch\n */\n/**\n * An object representing a JavaScript stack trace.\n * @typedef {Object} StackTrace\n * @property {string} name The name of the thrown exception.\n * @property {string} message The exception error message.\n * @property {ErrorWatch.StackFrame[]} stack An array of stack frames.\n * @property {string} mode 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace.\n * @memberof ErrorWatch\n */\n/**\n * ErrorWatch.computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   ```js\n *   s = ErrorWatch.computeStackTrace.ofCaller([depth])\n *   s = ErrorWatch.computeStackTrace(exception) // consider using ErrorWatch.report instead (see below)\n *   ```\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * ErrorWatch.computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with ErrorWatch.report,\n * which builds on top of ErrorWatch.computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n * Tracing example:\n *  ```js\n *     function trace(message) {\n *         var stackInfo = ErrorWatch.computeStackTrace.ofCaller();\n *         var data = message + \"\\n\";\n *         for(var i in stackInfo.stack) {\n *             var item = stackInfo.stack[i];\n *             data += (item.func || '[anonymous]') + \"() in \" + item.url + \":\" + (item.line || '0') + \"\\n\";\n *         }\n *         if (window.console)\n *             console.info(data);\n *         else\n *             alert(data);\n *     }\n * ```\n * @memberof ErrorWatch\n * @namespace\n */\nimport { remoteFetching, linesOfContext, debug, reportFuncName } from './config';\nimport { _has, _isUndefined } from './utils';\n\nconst UNKNOWN_FUNCTION = '?';\n\nlet sourceCache = {};\n\n/**\n * Attempts to retrieve source code via XMLHttpRequest, which is used\n * to look up anonymous function names.\n * @param {string} url URL of source code.\n * @return {string} Source contents.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction loadSource(url) {\n  if (!remoteFetching) { //Only attempt request if remoteFetching is on.\n    return '';\n  }\n  try {\n    const getXHR = function() {\n      try {\n        return new window.XMLHttpRequest();\n      } catch (e) {\n        // explicitly bubble up the exception if not found\n        return new window.ActiveXObject('Microsoft.XMLHTTP');\n      }\n    };\n\n    const request = getXHR();\n    request.open('GET', url, false);\n    request.send('');\n    return request.responseText;\n  } catch (e) {\n    return '';\n  }\n}\n\n/**\n * Retrieves source code from the source code cache.\n * @param {string} url URL of source code.\n * @return {Array.<string>} Source contents.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction getSource(url) {\n  if (typeof url !== 'string') {\n    return [];\n  }\n\n  if (!_has(sourceCache, url)) {\n    // URL needs to be able to fetched within the acceptable domain.  Otherwise,\n    // cross-domain errors will be triggered.\n    /*\n        Regex matches:\n        0 - Full Url\n        1 - Protocol\n        2 - Domain\n        3 - Port (Useful for internal applications)\n        4 - Path\n    */\n    let source = '',\n        domain = '';\n    try { domain = window.document.domain; } catch (e) { }\n    const match = /(.*)\\:\\/\\/([^:\\/]+)([:\\d]*)\\/{0,1}([\\s\\S]*)/.exec(url);\n    if (match && match[2] === domain) {\n      source = loadSource(url);\n    }\n    sourceCache[url] = source ? source.split('\\n') : [];\n  }\n\n  return sourceCache[url];\n}\n\n/**\n * Tries to use an externally loaded copy of source code to determine\n * the name of a function by looking at the name of the variable it was\n * assigned to, if any.\n * @param {string} url URL of source code.\n * @param {(string|number)} lineNo Line number in source code.\n * @return {string} The function name, if discoverable.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction guessFunctionName(url, lineNo) {\n  const reFunctionArgNames = /function ([^(]*)\\(([^)]*)\\)/,\n    reGuessFunction = /['\"]?([0-9A-Za-z$_]+)['\"]?\\s*[:=]\\s*(function|eval|new Function)/,\n    maxLines = 10,\n    source = getSource(url);\n  let line = '', m;\n\n  if (!source.length) {\n    return UNKNOWN_FUNCTION;\n  }\n\n  // Walk backwards from the first line in the function until we find the line which\n  // matches the pattern above, which is the function definition\n  for (let i = 0; i < maxLines; ++i) {\n    line = source[lineNo - i] + line;\n\n    if (!_isUndefined(line)) { // 这里有个bug，永远为 true\n      if ((m = reGuessFunction.exec(line))) {\n        return m[1];\n      } else if ((m = reFunctionArgNames.exec(line))) {\n        return m[1];\n      }\n    }\n  }\n\n  return UNKNOWN_FUNCTION;\n}\n\n/**\n * Retrieves the surrounding lines from where an exception occurred.\n * @param {string} url URL of source code.\n * @param {(string|number)} line Line number in source code to center around for context.\n * @return {?Array.<string>} Lines of source code.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction gatherContext(url, line) {\n  const source = getSource(url);\n\n  if (!source.length) {\n    return null;\n  }\n\n  let context = [],\n    // linesBefore & linesAfter are inclusive with the offending line.\n    // if linesOfContext is even, there will be one extra line\n    //   *before* the offending line.\n    linesBefore = Math.floor(linesOfContext / 2),\n    // Add one extra line if linesOfContext is odd\n    linesAfter = linesBefore + (linesOfContext % 2),\n    start = Math.max(0, line - linesBefore - 1),\n    end = Math.min(source.length, line + linesAfter - 1);\n\n  line -= 1; // convert to 0-based index\n\n  for (let i = start; i < end; ++i) {\n    if (!_isUndefined(source[i])) {\n      context.push(source[i]);\n    }\n  }\n\n  return context.length > 0 ? context : null;\n}\n\n/**\n * Escapes special characters, except for whitespace, in a string to be\n * used inside a regular expression as a string literal.\n * @param {string} text The string.\n * @return {string} The escaped string literal.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction escapeRegExp(text) {\n  return text.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#]/g, '\\\\$&');\n}\n\n/**\n * Escapes special characters in a string to be used inside a regular\n * expression as a string literal. Also ensures that HTML entities will\n * be matched the same as their literal friends.\n * @param {string} body The string.\n * @return {string} The escaped string.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction escapeCodeAsRegExpForMatchingInsideHTML(body) {\n  return escapeRegExp(body).replace('<', '(?:<|&lt;)').replace('>', '(?:>|&gt;)').replace('&', '(?:&|&amp;)').replace('\"', '(?:\"|&quot;)').replace(/\\s+/g, '\\\\s+');\n}\n\n/**\n * Determines where a code fragment occurs in the source code.\n * @param {RegExp} re The function definition.\n * @param {Array.<string>} urls A list of URLs to search.\n * @return {?Object.<string, (string|number)>} An object containing\n * the url, line, and column number of the defined function.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction findSourceInUrls(re, urls) {\n  let source, m;\n  for (let i = 0, j = urls.length; i < j; ++i) {\n    if ((source = getSource(urls[i])).length) {\n      source = source.join('\\n');\n      if ((m = re.exec(source))) {\n\n        return {\n          'url': urls[i],\n          'line': source.substring(0, m.index).split('\\n').length,\n          'column': m.index - source.lastIndexOf('\\n', m.index) - 1\n        };\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Determines at which column a code fragment occurs on a line of the\n * source code.\n * @param {string} fragment The code fragment.\n * @param {string} url The URL to search.\n * @param {(string|number)} line The line number to examine.\n * @return {?number} The column number.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction findSourceInLine(fragment, url, line) {\n  const source = getSource(url),\n    re = new RegExp('\\\\b' + escapeRegExp(fragment) + '\\\\b');\n  let m;\n\n  line -= 1;\n\n  if (source && source.length > line && (m = re.exec(source[line]))) {\n    return m.index;\n  }\n\n  return null;\n}\n\n/**\n * Determines where a function was defined within the source code.\n * @param {(Function|string)} func A function reference or serialized\n * function definition.\n * @return {?Object.<string, (string|number)>} An object containing\n * the url, line, and column number of the defined function.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction findSourceByFunctionBody(func) {\n  if (_isUndefined(window && window.document)) {\n    return null;\n  }\n\n  const urls = [window.location.href],\n    scripts = window.document.getElementsByTagName('script'),\n    code = '' + func,\n    codeRE = /^function(?:\\s+([\\w$]+))?\\s*\\(([\\w\\s,]*)\\)\\s*\\{\\s*(\\S[\\s\\S]*\\S)\\s*\\}\\s*$/,\n    eventRE = /^function on([\\w$]+)\\s*\\(event\\)\\s*\\{\\s*(\\S[\\s\\S]*\\S)\\s*\\}\\s*$/;\n  let body,\n    re,\n    parts,\n    result;\n\n  for (let i = 0; i < scripts.length; ++i) {\n    const script = scripts[i];\n    if (script.src) {\n      urls.push(script.src);\n    }\n  }\n\n  if (!(parts = codeRE.exec(code))) {\n    re = new RegExp(escapeRegExp(code).replace(/\\s+/g, '\\\\s+'));\n  }\n\n  // not sure if this is really necessary, but I don’t have a test\n  // corpus large enough to confirm that and it was in the original.\n  else {\n    const name = parts[1] ? '\\\\s+' + parts[1] : '',\n      args = parts[2].split(',').join('\\\\s*,\\\\s*');\n\n    body = escapeRegExp(parts[3]).replace(/;$/, ';?'); // semicolon is inserted if the function ends with a comment.replace(/\\s+/g, '\\\\s+');\n    re = new RegExp('function' + name + '\\\\s*\\\\(\\\\s*' + args + '\\\\s*\\\\)\\\\s*{\\\\s*' + body + '\\\\s*}');\n  }\n\n  // look for a normal function definition\n  if ((result = findSourceInUrls(re, urls))) {\n    return result;\n  }\n\n  // look for an old-school event handler function\n  if ((parts = eventRE.exec(code))) {\n    const event = parts[1];\n    body = escapeCodeAsRegExpForMatchingInsideHTML(parts[2]);\n\n    // look for a function defined in HTML as an onXXX handler\n    re = new RegExp('on' + event + '=[\\\\\\'\"]\\\\s*' + body + '\\\\s*[\\\\\\'\"]', 'i');\n\n    if ((result = findSourceInUrls(re, urls[0]))) {\n      return result;\n    }\n\n    // look for ???\n    re = new RegExp(body);\n\n    if ((result = findSourceInUrls(re, urls))) {\n      return result;\n    }\n  }\n\n  return null;\n}\n\n// Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.columnNumber = 69\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\n//\n// OPERA:\n// ex.message = ...message... (see the example below)\n// ex.name = ReferenceError\n// ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n// ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n/**\n * Computes stack trace information from the stack property.\n * Chrome and Gecko use this property.\n * @param {Error} ex\n * @return {?ErrorWatch.StackTrace} Stack trace information.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction computeStackTraceFromStackProp(ex) {\n  if (!ex.stack) {\n    return null;\n  }\n\n  const chrome = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i,\n    gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i,\n    winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i,\n\n    geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i,\n    chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/,\n\n    lines = ex.stack.split('\\n'),\n    reference = /^(.*) is undefined$/.exec(ex.message);\n  let stack = [],\n    // Used to additionally parse URL/line/column from eval frames\n    isEval,\n    submatch,\n    parts,\n    element;\n\n  for (let i = 0, j = lines.length; i < j; ++i) {\n    if ((parts = chrome.exec(lines[i]))) {\n      const isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n      isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n      if (isEval && (submatch = chromeEval.exec(parts[2]))) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = submatch[1]; // url\n        parts[3] = submatch[2]; // line\n        parts[4] = submatch[3]; // column\n      }\n      element = {\n        'url': !isNative ? parts[2] : null,\n        'func': parts[1] || UNKNOWN_FUNCTION,\n        'args': isNative ? [parts[2]] : [],\n        'line': parts[3] ? +parts[3] : null,\n        'column': parts[4] ? +parts[4] : null\n      };\n    } else if ( parts = winjs.exec(lines[i]) ) {\n      element = {\n        'url': parts[2],\n        'func': parts[1] || UNKNOWN_FUNCTION,\n        'args': [],\n        'line': +parts[3],\n        'column': parts[4] ? +parts[4] : null\n      };\n    } else if ((parts = gecko.exec(lines[i]))) {\n      isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n      if (isEval && (submatch = geckoEval.exec(parts[3]))) {\n        // throw out eval line/column and use top-most line number\n        parts[3] = submatch[1];\n        parts[4] = submatch[2];\n        parts[5] = null; // no column when eval\n      } else if (i === 0 && !parts[5] && !_isUndefined(ex.columnNumber)) {\n        // FireFox uses this awesome columnNumber property for its top frame\n        // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n        // so adding 1\n        // NOTE: this hack doesn't work if top-most frame is eval\n        stack[0].column = ex.columnNumber + 1;\n      }\n      element = {\n        'url': parts[3],\n        'func': parts[1] || UNKNOWN_FUNCTION,\n        'args': parts[2] ? parts[2].split(',') : [],\n        'line': parts[4] ? +parts[4] : null,\n        'column': parts[5] ? +parts[5] : null\n      };\n    } else {\n      continue;\n    }\n\n    if (!element.func && element.line) {\n      element.func = guessFunctionName(element.url, element.line);\n    }\n\n    element.context = element.line ? gatherContext(element.url, element.line) : null;\n    stack.push(element);\n  }\n\n  if (!stack.length) {\n    return null;\n  }\n\n  if (stack[0] && stack[0].line && !stack[0].column && reference) {\n    stack[0].column = findSourceInLine(reference[1], stack[0].url, stack[0].line);\n  }\n\n  return {\n    'mode': 'stack',\n    'name': ex.name,\n    'message': ex.message,\n    'stack': stack\n  };\n}\n\n/**\n * Computes stack trace information from the stacktrace property.\n * Opera 10+ uses this property.\n * @param {Error} ex\n * @return {?ErrorWatch.StackTrace} Stack trace information.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction computeStackTraceFromStacktraceProp(ex) {\n  // Access and store the stacktrace property before doing ANYTHING\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  const stacktrace = ex.stacktrace;\n  if (!stacktrace) {\n    return;\n  }\n\n  const opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i,\n    opera11Regex = / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\((.*)\\))? in (.*):\\s*$/i,\n    lines = stacktrace.split('\\n');\n  let stack = [],\n    parts;\n\n  for (let line = 0; line < lines.length; line += 2) {\n    let element = null;\n    if ((parts = opera10Regex.exec(lines[line]))) {\n      element = {\n        'url': parts[2],\n        'line': +parts[1],\n        'column': null,\n        'func': parts[3],\n        'args':[]\n      };\n    } else if ((parts = opera11Regex.exec(lines[line]))) {\n      element = {\n        'url': parts[6],\n        'line': +parts[1],\n        'column': +parts[2],\n        'func': parts[3] || parts[4],\n        'args': parts[5] ? parts[5].split(',') : []\n      };\n    }\n\n    if (element) {\n      if (!element.func && element.line) {\n        element.func = guessFunctionName(element.url, element.line);\n      }\n      if (element.line) {\n        try {\n          element.context = gatherContext(element.url, element.line);\n        } catch (exc) {}\n      }\n\n      if (!element.context) {\n        element.context = [lines[line + 1]];\n      }\n\n      stack.push(element);\n    }\n  }\n\n  if (!stack.length) {\n    return null;\n  }\n\n  return {\n    'mode': 'stacktrace',\n    'name': ex.name,\n    'message': ex.message,\n    'stack': stack\n  };\n}\n\n/**\n * NOT TESTED.\n * Computes stack trace information from an error message that includes\n * the stack trace.\n * Opera 9 and earlier use this method if the option to show stack\n * traces is turned on in opera:config.\n * @param {Error} ex\n * @return {?ErrorWatch.StackTrace} Stack information.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction computeStackTraceFromOperaMultiLineMessage(ex) {\n  // TODO: Clean this function up\n  // Opera includes a stack trace into the exception message. An example is:\n  //\n  // Statement on line 3: Undefined variable: undefinedFunc\n  // Backtrace:\n  //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/ErrorWatch/javascript-client/sample.js: In function zzz\n  //         undefinedFunc(a);\n  //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/ErrorWatch/javascript-client/sample.html: In function yyy\n  //           zzz(x, y, z);\n  //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/ErrorWatch/javascript-client/sample.html: In function xxx\n  //           yyy(a, a, a);\n  //   Line 1 of function script\n  //     try { xxx('hi'); return false; } catch(ex) { ErrorWatch.report(ex); }\n  //   ...\n\n  const lines = ex.message.split('\\n');\n  if (lines.length < 4) {\n    return null;\n  }\n\n  const lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i,\n    lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i,\n    lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i,\n    stack = [],\n    scripts = (window && window.document && window.document.getElementsByTagName('script'));\n  let inlineScriptBlocks = [],\n    parts;\n\n  for (let s in scripts) {\n    if (_has(scripts, s) && !scripts[s].src) {\n      inlineScriptBlocks.push(scripts[s]);\n    }\n  }\n\n  for (let line = 2; line < lines.length; line += 2) {\n    let item = null;\n    if ((parts = lineRE1.exec(lines[line]))) {\n      item = {\n        'url': parts[2],\n        'func': parts[3],\n        'args': [],\n        'line': +parts[1],\n        'column': null\n      };\n    } else if ((parts = lineRE2.exec(lines[line]))) {\n      item = {\n        'url': parts[3],\n        'func': parts[4],\n        'args': [],\n        'line': +parts[1],\n        'column': null // TODO: Check to see if inline#1 (+parts[2]) points to the script number or column number.\n      };\n      const relativeLine = (+parts[1]); // relative to the start of the <SCRIPT> block\n      const script = inlineScriptBlocks[parts[2] - 1];\n      if (script) {\n        let source = getSource(item.url);\n        if (source) {\n          source = source.join('\\n');\n          const pos = source.indexOf(script.innerText);\n          if (pos >= 0) {\n            item.line = relativeLine + source.substring(0, pos).split('\\n').length;\n          }\n        }\n      }\n    } else if ((parts = lineRE3.exec(lines[line]))) {\n      const url = window.location.href.replace(/#.*$/, '');\n      const re = new RegExp(escapeCodeAsRegExpForMatchingInsideHTML(lines[line + 1]));\n      const src = findSourceInUrls(re, [url]);\n      item = {\n        'url': url,\n        'func': '',\n        'args': [],\n        'line': src ? src.line : parts[1],\n        'column': null\n      };\n    }\n\n    if (item) {\n      if (!item.func) {\n        item.func = guessFunctionName(item.url, item.line);\n      }\n      const context = gatherContext(item.url, item.line);\n      const midline = (context ? context[Math.floor(context.length / 2)] : null);\n      if (context && midline.replace(/^\\s*/, '') === lines[line + 1].replace(/^\\s*/, '')) {\n        item.context = context;\n      } else {\n        // if (context) alert(\"Context mismatch. Correct midline:\\n\" + lines[i+1] + \"\\n\\nMidline:\\n\" + midline + \"\\n\\nContext:\\n\" + context.join(\"\\n\") + \"\\n\\nURL:\\n\" + item.url);\n        item.context = [lines[line + 1]];\n      }\n      stack.push(item);\n    }\n  }\n  if (!stack.length) {\n    return null; // could not parse multiline exception message as Opera stack trace\n  }\n\n  return {\n    'mode': 'multiline',\n    'name': ex.name,\n    'message': lines[0],\n    'stack': stack\n  };\n}\n\n/**\n * Adds information about the first frame to incomplete stack traces.\n * Safari and IE require this to get complete data on the first frame.\n * @param {ErrorWatch.StackTrace} stackInfo Stack trace information from\n * one of the compute* methods.\n * @param {string} url The URL of the script that caused an error.\n * @param {(number|string)} lineNo The line number of the script that\n * caused an error.\n * @param {string=} message The error generated by the browser, which\n * hopefully contains the name of the object that caused the error.\n * @return {boolean} Whether or not the stack information was\n * augmented.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n  let initial = {\n    'url': url,\n    'line': lineNo\n  };\n\n  if (initial.url && initial.line) {\n    stackInfo.incomplete = false;\n\n    if (!initial.func) {\n      initial.func = guessFunctionName(initial.url, initial.line);\n    }\n\n    if (!initial.context) {\n      initial.context = gatherContext(initial.url, initial.line);\n    }\n\n    const reference = / '([^']+)' /.exec(message);\n    if (reference) {\n      initial.column = findSourceInLine(reference[1], initial.url, initial.line);\n    }\n\n    if (stackInfo.stack.length > 0) {\n      if (stackInfo.stack[0].url === initial.url) {\n        if (stackInfo.stack[0].line === initial.line) {\n          return false; // already in stack trace\n        } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {\n          stackInfo.stack[0].line = initial.line;\n          stackInfo.stack[0].context = initial.context;\n          return false;\n        }\n      }\n    }\n\n    stackInfo.stack.unshift(initial);\n    stackInfo.partial = true;\n    return true;\n  } else {\n    stackInfo.incomplete = true;\n  }\n\n  return false;\n}\n\n/**\n * Computes stack trace information by walking the arguments.caller\n * chain at the time the exception occurred. This will cause earlier\n * frames to be missed but is the only way to get any stack trace in\n * Safari and IE. The top frame is restored by\n * {@link augmentStackTraceWithInitialElement}.\n * @param {Error} ex\n * @return {ErrorWatch.StackTrace=} Stack trace information.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction computeStackTraceByWalkingCallerChain(ex, depth) {\n  const functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i;\n  let stack = [],\n    funcs = {},\n    recursion = false,\n    parts,\n    item,\n    source;\n\n  for (let curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n    if (curr === computeStackTrace || (curr && curr.__name__ === reportFuncName)) { // curr ===  report 避免循环依赖\n      continue;\n    }\n\n    item = {\n      'url': null,\n      'func': UNKNOWN_FUNCTION,\n      'args': [],\n      'line': null,\n      'column': null\n    };\n\n    if (curr.name) {\n      item.func = curr.name;\n    } else if ((parts = functionName.exec(curr.toString()))) {\n      item.func = parts[1];\n    }\n\n    if (typeof item.func === 'undefined') {\n      try {\n        item.func = parts.input.substring(0, parts.input.indexOf('{'));\n      } catch (e) { }\n    }\n\n    if ((source = findSourceByFunctionBody(curr))) {\n      item.url = source.url;\n      item.line = source.line;\n\n      if (item.func === UNKNOWN_FUNCTION) {\n        item.func = guessFunctionName(item.url, item.line);\n      }\n\n      const reference = / '([^']+)' /.exec(ex.message || ex.description);\n      if (reference) {\n        item.column = findSourceInLine(reference[1], source.url, source.line);\n      }\n    }\n\n    if (funcs['' + curr]) {\n      recursion = true;\n    }else{\n      funcs['' + curr] = true;\n    }\n\n    stack.push(item);\n  }\n\n  if (depth) {\n    stack.splice(0, depth);\n  }\n\n  let result = {\n    'mode': 'callers',\n    'name': ex.name,\n    'message': ex.message,\n    'stack': stack\n  };\n  augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);\n  return result;\n}\n\n/**\n * Computes a stack trace for an exception.\n * @param {Error} ex\n * @param {(string|number)=} depth\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction computeStackTrace(ex, depth) {\n  let stack = null;\n  depth = (depth == null ? 0 : +depth);\n\n  try {\n    // This must be tried first because Opera 10 *destroys*\n    // its stacktrace property if you try to access the stack\n    // property first!!\n    stack = computeStackTraceFromStacktraceProp(ex);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromStackProp(ex);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromOperaMultiLineMessage(ex);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n\n  try {\n    stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n\n  return {\n    'name': ex.name,\n    'message': ex.message,\n    'mode': 'failed'\n  };\n}\n\n/**\n * Logs a stacktrace starting from the previous call and working down.\n * @param {(number|string)=} depth How many frames deep to trace.\n * @return {ErrorWatch.StackTrace} Stack trace information.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction computeStackTraceOfCaller(depth) {\n  depth = (depth == null ? 0 : +depth) + 1; // \"+ 1\" because \"ofCaller\" should drop one frame\n  try {\n    throw new Error();\n  } catch (ex) {\n    return computeStackTrace(ex, depth + 1);\n  }\n}\n\ncomputeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\ncomputeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\ncomputeStackTrace.guessFunctionName = guessFunctionName;\ncomputeStackTrace.gatherContext = gatherContext;\ncomputeStackTrace.ofCaller = computeStackTraceOfCaller;\ncomputeStackTrace.getSource = getSource;\n\nexport default computeStackTrace;\n","import { collectSourceErrors } from './config';\n\nlet isRegisterListener = false;\nlet _handler = null;\n\n/**\n * 资源加载错误上报\n * @param handler\n */\nexport function installResourceLoadError(handler) {\n  if(!isRegisterListener && collectSourceErrors) {\n    _handler = handler;\n    window.addEventListener && window.addEventListener('error', function (e) {\n      try {\n        if(e.target !== window) {  // 避免重复上报\n          const stack = {\n            message: `${e.target.localName} is load error`,\n            mode: 'resource',\n            name: e.target.src || e.target.href || e.target.currentSrc,\n            stack: null,\n          };\n          handler(stack, true, e);\n        }\n      } catch (e) {\n        throw e;\n      }\n    }, true);\n  }\n  isRegisterListener = true;\n}\n\n/**\n * 移除资源错误加载监听\n */\nexport function uninstallResourceLoadError() {\n  if(isRegisterListener && collectSourceErrors && _handler) {\n    window.removeEventListener && window.removeEventListener('error', _handler);\n    _handler = null;\n    isRegisterListener = false;\n  }\n}\n","/**\n * Cross-browser processing of unhandled exceptions\n *\n * Syntax:\n * ```js\n *   ErrorWatch.report.subscribe(function(stackInfo) { ... })\n *   ErrorWatch.report.unsubscribe(function(stackInfo) { ... })\n *   ErrorWatch.report(exception)\n *   try { ...code... } catch(ex) { ErrorWatch.report(ex); }\n * ```\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *     on top frame; column number is not guaranteed\n *   - Opera: full stack trace with line and column numbers\n *   - Chrome: full stack trace with line and column numbers\n *   - Safari: line and column number for the top frame only; some frames\n *     may be missing, and column number is not guaranteed\n *   - IE: line and column number for the top frame only; some frames\n *     may be missing, and column number is not guaranteed\n *\n * In theory, ErrorWatch should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires ErrorWatch.computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that ErrorWatch.report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where ErrorWatch.report was called.\n *\n * Handlers receive a ErrorWatch.StackTrace object as described in the\n * ErrorWatch.computeStackTrace docs.\n *\n * @memberof ErrorWatch\n * @namespace\n */\n\nimport computeStackTrace from './computeStackTrace';\nimport {collectWindowErrors, reportFuncName} from './config';\nimport { _has } from './utils';\nimport { installResourceLoadError, uninstallResourceLoadError } from './resourceError';\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;\n\n\nlet handlers = [],\n  lastException = null,\n  lastExceptionStack = null;\n\n/**\n * Add a crash handler.\n * @param {Function} handler\n * @memberof ErrorWatch.report\n */\nfunction subscribe(handler) {\n  installGlobalHandler();\n  installGlobalUnhandledRejectionHandler();\n  handlers.push(handler);\n}\n\n/**\n * Remove a crash handler.\n * @param {Function} handler\n * @memberof ErrorWatch.report\n */\nfunction unsubscribe(handler) {\n  for (let i = handlers.length - 1; i >= 0; --i) {\n    if (handlers[i] === handler) {\n      handlers.splice(i, 1);\n    }\n  }\n\n  if (handlers.length === 0) {\n    uninstallGlobalHandler();\n    uninstallGlobalUnhandledRejectionHandler();\n  }\n}\n\n/**\n * Dispatch stack information to all handlers.\n * @param {ErrorWatch.StackTrace} stack\n * @param {boolean} isWindowError Is this a top-level window error?\n * @param {Error=} error The error that's being handled (if available, null otherwise)\n * @memberof ErrorWatch.report\n * @throws An exception if an error occurs while calling an handler.\n */\nfunction notifyHandlers(stack, isWindowError, error) {\n  let exception = null;\n  if (isWindowError && !collectWindowErrors) {\n    return;\n  }\n  for (let i in handlers) {\n    if (_has(handlers, i)) {\n      try {\n        handlers[i](stack, isWindowError, error);\n      } catch (inner) {\n        exception = inner;\n      }\n    }\n  }\n\n  if (exception) {\n    throw exception;\n  }\n}\n\nlet _oldOnerrorHandler, _onErrorHandlerInstalled;\nlet _oldOnunhandledrejectionHandler, _onUnhandledRejectionHandlerInstalled;\n\n/**\n * Ensures all global unhandled exceptions are recorded.\n * Supported by Gecko and IE.\n * @param {string} message Error message.\n * @param {string} url URL of script that generated the exception.\n * @param {(number|string)} lineNo The line number at which the error occurred.\n * @param {(number|string)=} columnNo The column number at which the error occurred.\n * @param {Error=} errorObj The actual Error object.\n * @memberof ErrorWatch.report\n */\nfunction errorWatchWindowOnError(message, url, lineNo, columnNo, errorObj) {\n  let stack = null;\n\n  if (lastExceptionStack) {\n    computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);\n    processLastException();\n  } else if (errorObj) {\n    stack = computeStackTrace(errorObj);\n    notifyHandlers(stack, true, errorObj);\n  } else {\n    let location = {\n      'url': url,\n      'line': lineNo,\n      'column': columnNo\n    };\n\n    let name;\n    let msg = message; // must be new var or will modify original `arguments`\n    if ({}.toString.call(message) === '[object String]') {\n      const groups = message.match(ERROR_TYPES_RE);\n      if (groups) {\n        name = groups[1];\n        msg = groups[2];\n      }\n    }\n\n    location.func = computeStackTrace.guessFunctionName(location.url, location.line);\n    location.context = computeStackTrace.gatherContext(location.url, location.line);\n    stack = {\n      'name': name,\n      'message': msg,\n      'mode': 'onerror',\n      'stack': [location]\n    };\n\n    notifyHandlers(stack, true, null);\n  }\n\n  if (_oldOnerrorHandler) {\n    return _oldOnerrorHandler.apply(this, arguments);\n  }\n\n  return false;\n}\n\n/**\n * Ensures all unhandled rejections are recorded.\n * @param {PromiseRejectionEvent} e event.\n * @memberof ErrorWatch.report\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onunhandledrejection\n * @see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n */\nfunction errorWatchWindowOnUnhandledRejection(e) {\n  const stack = computeStackTrace(e.reason);\n  notifyHandlers(stack, true, e.reason);\n}\n\n/**\n * Install a global onerror handler\n * @memberof ErrorWatch.report\n */\nfunction installGlobalHandler() {\n  if (_onErrorHandlerInstalled === true) {\n    return;\n  }\n\n  _oldOnerrorHandler = window.onerror;\n  window.onerror = errorWatchWindowOnError;\n  installResourceLoadError(function handleResourceError(stack, isWindowError, error) {\n    notifyHandlers(stack, isWindowError, error);\n  });\n  _onErrorHandlerInstalled = true;\n}\n\n/**\n * Uninstall the global onerror handler\n * @memberof ErrorWatch.report\n */\nfunction uninstallGlobalHandler() {\n  if (_onErrorHandlerInstalled) {\n    window.onerror = _oldOnerrorHandler;\n    uninstallResourceLoadError();\n    _onErrorHandlerInstalled = false;\n  }\n}\n\n/**\n * Install a global onunhandledrejection handler\n * @memberof ErrorWatch.report\n */\nfunction installGlobalUnhandledRejectionHandler() {\n  if (_onUnhandledRejectionHandlerInstalled === true) {\n    return;\n  }\n\n  _oldOnunhandledrejectionHandler = window.onunhandledrejection;\n  window.onunhandledrejection = errorWatchWindowOnUnhandledRejection;\n  _onUnhandledRejectionHandlerInstalled = true;\n}\n\n/**\n * Uninstall the global onunhandledrejection handler\n * @memberof ErrorWatch.report\n */\nfunction uninstallGlobalUnhandledRejectionHandler() {\n  if (_onUnhandledRejectionHandlerInstalled) {\n    window.onunhandledrejection = _oldOnunhandledrejectionHandler;\n    _onUnhandledRejectionHandlerInstalled = false;\n  }\n}\n\n/**\n * Process the most recent exception\n * @memberof ErrorWatch.report\n */\nfunction processLastException() {\n  let _lastExceptionStack = lastExceptionStack,\n    _lastException = lastException;\n  lastExceptionStack = null;\n  lastException = null;\n  notifyHandlers(_lastExceptionStack, false, _lastException);\n}\n\n/**\n * Reports an unhandled Error to ErrorWatch.\n * @param {Error} ex\n * @memberof ErrorWatch.report\n * @throws An exception if an incomplete stack trace is detected (old IE browsers).\n */\nfunction report(ex) {\n  if (lastExceptionStack) {\n    if (lastException === ex) {\n      return; // already caught by an inner catch block, ignore\n    } else {\n      processLastException();\n    }\n  }\n\n  const stack = computeStackTrace(ex);\n  lastExceptionStack = stack;\n  lastException = ex;\n\n  // If the stack trace is incomplete, wait for 2 seconds for\n  // slow slow IE to see if onerror occurs or not before reporting\n  // this exception; otherwise, we will end up with an incomplete\n  // stack trace\n  setTimeout(function () {\n    if (lastException === ex) {\n      processLastException();\n    }\n  }, (stack.incomplete ? 2000 : 0));\n\n  throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n}\n\nreport.subscribe = subscribe;\nreport.unsubscribe = unsubscribe;\n\nreport.__name__ = reportFuncName;\n\nexport default report;\n","import report from \"./report\";\n\n/**\n * Wrap any function in a ErrorWatch reporter<br/>\n * Example: `func = ErrorWatch.wrap(func);`\n *\n * @param {Function} func Function to be wrapped\n * @return {Function} The wrapped func\n * @memberof ErrorWatch\n */\nexport function wrap(func) {\n  function wrapped() {\n    try {\n      return func.apply(this, arguments);\n    } catch (e) {\n      report(e);\n      throw e;\n    }\n  }\n  return wrapped;\n}\n","import { wrap } from './wrap';\n\n// global reference to slice\nconst _slice = [].slice;\n\n/**\n * Extends support for global error handling for asynchronous browser\n * functions. Adopted from Closure Library's errorhandler.js\n * @memberof ErrorWatch\n */\nfunction _helper(fnName) {\n  const originalFn = window[fnName];\n\n  window[fnName] = function errorWatchAsyncExtension() {\n    // Make a copy of the arguments\n    let args = _slice.call(arguments);\n    const originalCallback = args[0];\n    if (typeof (originalCallback) === 'function') {\n      args[0] = wrap(originalCallback);\n    }\n    // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it\n    // also only supports 2 argument and doesn't care what \"this\" is, so we\n    // can just call the original function directly.\n    if (originalFn.apply) {\n      return originalFn.apply(this, args);\n    } else {\n      return originalFn(args[0], args[1]);\n    }\n  };\n}\n\nexport function extendToAsynchronousCallbacks() {\n  _helper('setTimeout');\n  _helper('setInterval');\n}\n","import report from './report';\nimport computeStackTrace from './computeStackTrace';\nimport {wrap} from './wrap';\nimport { extendToAsynchronousCallbacks } from './tryCatch';\n\nconst _oldErrorWatch = window.ErrorWatch;\nlet ErrorWatch;\n/**\n * Export ErrorWatch out to another variable<br/>\n * Example: `var TK = ErrorWatch.noConflict()`\n * @return {Object} The ErrorWatch object\n * @memberof ErrorWatch\n */\nfunction noConflict() {\n  window.ErrorWatch = _oldErrorWatch;\n  return ErrorWatch;\n}\n\nfunction makeError() {\n  const tmp = thisIsAbug;\n  return tmp + '';\n}\n\nErrorWatch =  {\n  noConflict,\n  report,\n  computeStackTrace,\n  wrap,\n  extendToAsynchronousCallbacks,\n  makeError,\n};\n\nexport default ErrorWatch;\n"],"names":["collectWindowErrors","collectSourceErrors","linesOfContext","reportFuncName","_has","object","key","Object","prototype","hasOwnProperty","call","_isUndefined","what","UNKNOWN_FUNCTION","sourceCache","getSource","url","source","domain","window","document","e","match","exec","split","guessFunctionName","lineNo","m","reFunctionArgNames","reGuessFunction","line","length","i","gatherContext","context","linesBefore","Math","floor","linesAfter","start","max","end","min","push","escapeRegExp","text","replace","escapeCodeAsRegExpForMatchingInsideHTML","body","findSourceInUrls","re","urls","j","join","substring","index","lastIndexOf","findSourceInLine","fragment","RegExp","findSourceByFunctionBody","func","parts","result","location","href","scripts","getElementsByTagName","code","script","src","name","args","event","computeStackTraceFromStackProp","ex","stack","submatch","element","chrome","gecko","winjs","geckoEval","chromeEval","lines","reference","message","isNative","indexOf","columnNumber","column","augmentStackTraceWithInitialElement","stackInfo","initial","incomplete","unshift","partial","computeStackTraceByWalkingCallerChain","depth","item","functionName","funcs","recursion","curr","caller","computeStackTrace","__name__","toString","input","description","splice","sourceURL","fileName","lineNumber","stacktrace","opera10Regex","opera11Regex","exc","computeStackTraceFromStacktraceProp","lineRE1","lineRE2","lineRE3","inlineScriptBlocks","s","relativeLine","pos","innerText","midline","computeStackTraceFromOperaMultiLineMessage","ofCaller","Error","isRegisterListener","_handler","_oldOnerrorHandler","_onErrorHandlerInstalled","_oldOnunhandledrejectionHandler","_onUnhandledRejectionHandlerInstalled","ERROR_TYPES_RE","handlers","lastException","lastExceptionStack","notifyHandlers","isWindowError","error","exception","inner","errorWatchWindowOnError","columnNo","errorObj","processLastException","msg","groups","apply","this","arguments","errorWatchWindowOnUnhandledRejection","reason","_lastExceptionStack","_lastException","report","setTimeout","wrap","subscribe","handler","onerror","addEventListener","target","localName","mode","currentSrc","installResourceLoadError","installGlobalHandler","onunhandledrejection","installGlobalUnhandledRejectionHandler","unsubscribe","removeEventListener","_slice","slice","_helper","fnName","originalFn","originalCallback","ErrorWatch","_oldErrorWatch","noConflict","extendToAsynchronousCallbacks","makeError","thisIsAbug"],"mappings":"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"}